\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
%\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{hyperref}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59pm, 2/4, 2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Student ID: 862389624 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

\begin{document}

\assigntitle{2}{}
\policy{\textbf{Deadline.} The homework is due 11:59pm, Mon 2/4, 2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
\end{itemize}


}

\section{Finding Local Minima (20 points) }


\subsection{Linear Time (5 pts)}
Linear-time algorithm to find a local minimum in an array of size $n$.
Given an array $A$ of size $n$.
\begin{itemize}
  \item int \textbf{localMin}(int A[], int n)
    \begin{itemize}
      \item \textbf{if} (n == 1) \textbf{return} A[0]; // Base case
      \item \textbf{if} (A[0] < A[1]) \textbf{return} A[0]; // Check the first element
      \item \textbf{if} (A[n-1] < A[n-2]) \textbf{return} A[n-1]; // Check the last element
      \item \textbf{for} (int i = 1; i < n-1; i++) // Check the rest of the elements
        \begin{itemize}
          \item \textbf{if} (A[i] < A[i-1] \textbf{AND} A[i] < A[i+1]) \textbf{return} A[i];
        \end{itemize}
    \end{itemize}
  \item This algorithm has a time complexity of $\Theta(n)$
  \begin{itemize}
    \item Every part of the function is \Theta(1) until the for loop
    \item The For loop runs for $n-2$ iterations (ignoring the base cases, start, and end)
  \end{itemize}
\end{itemize}

\pagebreak

\vspace*{10px}
\subsection{Log Solution (10 pts)}

\begin{itemize}
  \item The algorithm that we will use to find the local minimum is a binary search algorithm.
  \item Since we already know binary search trees are $\log n$ height, we can use this to our advantage.
  \item The algorithm will be $\Theta(\log n)$
  \item The algorithm will be as follows:
  \item int \textbf{localMinBST}(int A[], int low, int high)
    \begin{itemize}
      \item \textbf{if} (low == high) \textbf{return} A[low]; // Base case
      \item int mid = low + (high - low) / 2;
      \item \textbf{if} (A[mid] < A[mid-1] \textbf{AND} A[mid] < A[mid+1]) \textbf{return} A[mid];
      \item \textbf{if} (A[mid-1] < A[mid]) \textbf{return} \textbf{localMinBST}(A, low, mid-1);
      \item \textbf{else} \textbf{return} \textbf{localMinBST}(A, mid+1, high);
    \end{itemize}
  \item int \textbf{localMin}(int A[], int n) \{ \textbf{return} \textbf{localMinBST}(A, 0, n-1); \}
  \item The helper function \textbf{localMinBST} 
    will be the recursive function that will find the local minimum.
\end{itemize}

\vspace*{10px}
\subsection{Recurrence (5 pts)}
Justification:
\begin{itemize}
  \item The binary search algorithm divides the array in half each recursive call
  \item The recurrence relation is $T(n) = T(\frac{n}{2}) + 1$
  \item This algorithm is $\Theta(\log n)$ due to the $(\log n)$ height of binary search trees
  \item Then every single action/comparison within the function is constant time
\end{itemize}




\newpage
\section{Solve the Recurrences (15 points)}

\subsection{$T(n) = 3T\left(\frac{n}{2}\right) + \frac{n^2}{\log^2 n}$}

\begin{itemize}
  \item The pattern that this recurrence follows is as this:
  \item Given $k$ = 1
\end{itemize}

\begin{equation*}
  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + 3^{k-1} \frac{(\frac{n}{2^{k-1}})^{2}}{\log^2 (\frac{n}{2^{k-1}})}
  \Rightarrow
%  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + (\frac{3}{4})^{k-1} \frac{(\frac{n}{2^{k-1}})^{2}}{\log^2 (\frac{n}{2^{k-1}})}
  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + (\frac{3}{4})^{k-1} \frac{(n^{2})}{\log^2 (\frac{n}{2^{k-1}})}
\end{equation*}

\begin{itemize}
  \item We can now solve for $k$ given the base case $T(1) = 1$
  \item $T(1)$ = $\frac{n}{2^{k}}$ = 1
  \item $n$ = $2^{k}$
  \item $k$ = $\log n$
  \item Now to solve the recurrence we can plug in $k$ = $\log n$
\end{itemize}

\begin{equation*}
  \sum_{k=1}^{\log n} (\frac{3}{4})^{k-1} \frac{(n^{2})}{\log^2 (\frac{n}{2^{k-1}})}
  \Rightarrow
  n^{2} \sum_{k=1}^{\log n} \frac{(3/4)^{k}}{\log^2 (\frac{n}{2^{k-1}})}
  \Rightarrow
  n^{2} \sum_{k=1}^{\log n} \frac{(3/4)^{k}}{\log^2 n}
\end{equation*}

\begin{itemize}
  \item This summation would converge to:
\end{itemize}

\begin{equation*}
  \frac{n^2}{\log^2 n} \sum_{k=1}^{\log n} (3/4)^{k}
  \Rightarrow
  \Theta(\frac{n^2}{\log^2 n})
\end{equation*}


\pagebreak

\vspace*{10px}
\subsection{$T(n) = T\left(\frac{n}{4}\right) + T\left(\frac{3n}{4}\right) + n \log n$}
\begin{itemize}
  \item The pattern that this recurrence follows is as this:
  \item Given $k$ = 1
\end{itemize}

\begin{equation*}
  T(n) = T(\frac{n}{4^{k}}) + T(\frac{3^{k}n}{4^{k}}) + \frac{n \log n}{4^{k}} + \frac{3n (\log 3n - \log 3^{k})}{4^{k}}
\end{equation*}
\begin{itemize}
  \item We can now solve for $k$ given the base case $T(1) = 1$
  \item Using the base case of $T(1)=1$ we can solve for $k$
  \item $T(1)$ = $\frac{n}{4^{k}}$ = 1
  \item $n$ = $4^{k}$
  \item $k$ = $\log n$
  \item Now to solve the recurrence we can plug in $k$ = $\log n$
  \item $T(n)$ = $T(1) + T(3n) + n \log n$
  \item $T(n)$ = $1 + T(3n) + n \log n$
  \item Given that we have a $k$ = $\log n$ we can solve for the recurrence
\end{itemize}
\begin{equation*}
  \sum_{k=0}^{\log n} 3^{k} + n \log n
  \Rightarrow 3^{\log n} + n \log n
  \Rightarrow n^{\log 3} + n \log n
  \Rightarrow \sum_{k=0}^{\log n} n \log n
\end{equation*}
\begin{equation*}
  n \log n \log n
  \Rightarrow \Theta(n \log^{2} n)
\end{equation*}
\begin{itemize}
  \item After focusing on the highest growing part of the summation
    we can conclude that this recurrence is $\Theta(n \log^{2} n)$.
\end{itemize}


\pagebreak

\vspace*{10px}
\subsection{$T(n) = 3T\left(\frac{n}{2}\right) + n^2$}
\begin{itemize}
  \item The pattern that this recurrence follows is as this (in a summation form):
  \item Given $k$ = 1
\end{itemize}

\begin{equation*}
  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + 3^{k-1} (\frac{n}{2^{k-1}})^{2}
  \Rightarrow
  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + 3^{k-1} (\frac{n^{2}}{4^{k-1}}) \\
\end{equation*}
\begin{equation*}
  \Rightarrow
  T(n) = 3^{k} T\left(\frac{n}{2^{k}}\right) + (\frac{3}{4})^{k-1} (n^{2})
\end{equation*}

\begin{itemize}
  \item We can now solve for $k$ given the base case $T(1) = 1$
  \item $T(1)$ = $\frac{n}{2^{k}}$ = 1
  \item $n$ = $2^{k}$
  \item $k$ = $\log n$
  \item Now to solve the recurrence we can plug in $k$ = $\log n$
  \item $T(n)$ = $3^{\log n} T(1) + (\frac{3}{4})^{\log n - 1} n^{2}$
  \item $T(n)$ = $n^{\log 3} + (\frac{3}{4})^{\log n - 1} n^{2}$
  \item $T(n)$ = $n^{\log 3} + (\frac{3}{4})^{\log n} n^{2}$
  \item Looking at this equation we can see that the second term is $O(n^{2})$
  \item Therefore the overall time complexity is $O(n^{2})$
\end{itemize}

\newpage

\section{Significant Inversion (15 points)}

\subsection{Algorithm (10 pts)}
\begin{algorithm}[H]
\caption{CountSignificantInversions(X, low, high)}
\If {low $\geq$ high} {return 0;}
mid = (low + high) / 2\;
count = CountSI(X, low, mid) + CountSI(X, mid+1, high)\;
j = mid+1\;
\For {i = low to mid} {
  \While {j $\leq$ high \textbf{AND} X[i] $\geq$ 2 \cdot X[j]} {
    ++j\;
  }
  count += j - (mid+1)\;
}
Merge(X, low, mid, high)\;
Return count\;

\end{algorithm}

\vspace*{10px}
\subsection{Recurrence \& Time Complexity (5 pts)}
\begin{itemize}
  \item The recurrence relation for this algorithm is $T(n) = 2T(\frac{n}{2}) + O(n)$
  \item The algorithm is called twice within the code and the 
    array is split in half for each call. Making the algorithm 
    2T($\frac{n}{2}$)
  \item The $O(n)$ comes from the for loop that iterates through the array
  \item Using master's theorem,
    $n^{\log_{2} 2}$ = n$^{1}$ = n.
    Which is equal to the $O(n)$ in the recurrence relation
  \item This algorithm is $\Theta(n \log n)$
\end{itemize}

\newpage
\section{Data Recovery (15 points)}
\subsection{Algorithm (10 pts}

\vspace*{10px}
\subsection{Recurrence \& Time Complexity (5 pts)}

\newpage
\section{Modified Merge Sort (20 pts)}

\vspace*{10px}
\subsection{Recurrence Relation (10 pts)}

\vspace*{10px}
\subsection{Solve the Recurrence (10 pts)}

\vspace*{10px}
\subsection{Compare (5 pts)}

\newpage
\section{Molecular Matching (15 points)}


\end{document}
