\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59 PM, 3/4/2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Net ID: dtope004 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

\def\isinput{} % Exclude preamble in questions
\begin{document}

\assigntitle{4}{}
\policy{\textbf{Deadline.} The homework is due 11:59 PM, 3/4/2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
    \item Unless stated in the question, your designed algorithm should use the most optimized algorithm you have learned so far. A too-complex algorithm may result in penalties.
\end{itemize}


}

\section{0/1 Knapsack (20 points)}
\subsection{Part A (10 Points)}

\noindent\textbf{Recurrence:} \\

  
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item The $DP[i][j]$ represents 
  \item Given budget $j$, the maximum value that can be obtained by including the first $i$ items.
\end{itemize}
\noindent\textbf{Dimensions:} \\
The dimensionality of $DP[i][j]$ is 2 dimensional.
\begin{enumerate}
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
\end{enumerate}

\pagebreak
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/1 Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items $n$ inidexed by $i$ with weights $w_i$ and a budget $w$ and values $v_i$}
\KwOut{Maximum value that can be obtained with at most one each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n \times w$ initialized with 0,0 \;
  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{

      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;

      \Comment{Case 2: Take item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[j])$\;
      }
    }
  }

  \Return{$dp[i][j]$} \;
}
\end{algorithm}

\newpage
\subsection{Part B (10 Points)}
New problem statement, instead of being limited to 0 or 1 item, now we can have 0, 1, or 2 of the item.
We want to have the maximum value of the items without exceeding the weight limit of the Knapsack.\\

\noindent\textbf{Recurrence:} \\
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
     DP[i-1][j-2w_i] + 2v_i & \text{if } j > 2w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item Just like the previous problem, the $DP[i][j]$ represents the maximum value that can be obtained by including the first $i$ items.
  \item The only difference is that we can have 0, 1, or 2 of the item. This can be represented by the second dimension $j$.
    \begin{itemize}
      \item Showing that we can have 0,1,2 items is modified by adding one more case to the recurrence.
    \end{itemize}
\end{itemize}
\noindent\textbf{Dimensions:} \\
\begin{itemize}
  \item The dimensionality of $DP[i][j]$ is 2 dimensional.
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
  
\end{itemize}

\pagebreak 
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/I Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items indexed by $i$ with weights $w_i$ and values $v_i$ and a budget $w$}
\KwOut{Maximum value that can be obtained with at most two of each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n+1 \times w+1$ initialized with 0,0 \; 

  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{
      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;
      \Comment{Case 2: Take 1 of item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[i])$\;
      }
      \Comment{Case 3: Take 2 of item 1}

      \If{$j \geq 2w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-2w[i]] + 2value[i])$\;
      }
    }
  }

  \Return{$dp[n][w]$} \;
}
\end{algorithm}

\newpage
\section{Modified Edit Distance (20 points)}
\subsection{Part A (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Either insert or delete
  %min(DP[i-1][j] + 1, DP[i][j-1] + 1)  & \text{otherwise}
  DP[i-1][j] + 1 & \text{if } (A[i] \neq B[j])\\ 
  DP[i][j-1] + 1 & \text{if } (A[i] \neq B[j])\\ 
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills an $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.
\end{itemize}

\newpage
\section{Part B (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Deletion
  DP[i-1][j] + C_D & \text{if } (A[i] \neq B[j])\\
  % Insertion
  DP[i][j-1] + C_I & \text{if } (A[i] \neq B[j])\\
  % Modification
  DP[i-1][j-1] + C_M & \text{if } (A[i] \neq B[j])
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills an $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.
  \item Despite the added cost of modification, the time complexity remains the same.
    Since the table is filled in constant time, the time complexity is not affected.
\end{itemize}

\newpage
\section{Tipping the Scales (20 points)}
\noindent\textbf{Algorithm:} \\
Describe the algorithm here: \\
\begin{itemize}
  \item Input: Array B[] size $n$ of balance thresholds and array W[] size $n$ of stone weights.
  \item Output: Maximum number of balances that can be tipped.
\end{itemize}

\begin{enumerate}
  \item Sort $B[]$ and $W[]$ increasing order
  \item Init $count$ = 0
  \item Init $i = 1$ (index for balances), $j = 1$ (index for stones)
  \item While $i$ \leq $n$ and $j$ \leq $n$ do:
    \begin{enumerate}
      \item If $W[j]$ \leq $B[i]$ then:
        \begin{enumerate}
          \item Assign $j$ to balance $i$
          \item Increment $i$
          \item Increment $i$ and $j$
        \end{enumerate}
        Else:
        \begin{enumerate}
          \item Increment $j$ // Stone too light, try next one
        \end{enumerate}
    \end{enumerate}
  \item Return $count$
\end{enumerate}
\noindent\textbf{Greedy Choice:} \\
\noindent\textbf{Optimal Substructure:} \\

\newpage
\section{High Throughput (20 points)}
\noindent\textbf{Algorithm:} \\
\noindent\textbf{Greedy Choice:} \\
\noindent\textbf{Optimal Substructure:} \\

\newpage
\section{Task Scheduling (20 points)}


\end{document}

