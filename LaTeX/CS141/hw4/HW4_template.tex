\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59 PM, 3/4/2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Net ID: dtope004 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

\def\isinput{} % Exclude preamble in questions
\begin{document}

\assigntitle{4}{}
\policy{\textbf{Deadline.} The homework is due 11:59 PM, 3/4/2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
    \item Unless stated in the question, your designed algorithm should use the most optimized algorithm you have learned so far. A too-complex algorithm may result in penalties.
\end{itemize}


}

\section{0/1 Knapsack (20 points)}
\subsection{Part A (10 Points)}

\noindent\textbf{Recurrence:} \\

  
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item The $DP[i][j]$ represents 
  \item Given budget $j$, the maximum value that can be obtained by including the first $i$ items.
\end{itemize}
\noindent\textbf{Dimensions:} \\
The dimensionality of $DP[i][j]$ is 2-dimensional.
\begin{enumerate}
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
\end{enumerate}

\pagebreak
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/1 Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items $n$ inidexed by $i$ with weights $w_i$ and a budget $w$ and values $v_i$}
\KwOut{Maximum value that can be obtained with at most one each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n \times w$ initialized with 0,0 \;
  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{

      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;

      \Comment{Case 2: Take item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[j])$\;
      }
    }
  }

  \Return{$dp[i][j]$} \;
}
\end{algorithm}

\newpage
\subsection{Part B (10 Points)}
New problem statement, instead of being limited to 0 or 1 item, now we can have 0, 1, or 2 of the item.
We want to have the maximum value of the items without exceeding the weight limit of the Knapsack.\\

\noindent\textbf{Recurrence:} \\
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
     DP[i-1][j-2w_i] + 2v_i & \text{if } j > 2w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item Just like the previous problem, the $DP[i][j]$ represents the maximum value that can be obtained by including the first $i$ items.
  \item The only difference is that we can have 0, 1, or 2 of the item. This can be represented by the second dimension $j$.
    \begin{itemize}
      \item Showing that we can have 0,1,2 items is modified by adding one more case to the recurrence.
    \end{itemize}
\end{itemize}
\noindent\textbf{Dimensions:} \\
\begin{itemize}
  \item The dimensionality of $DP[i][j]$ is 2 dimensional.
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
  
\end{itemize}

\pagebreak 
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/I Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items indexed by $i$ with weights $w_i$ and values $v_i$ and a budget $w$}
\KwOut{Maximum value that can be obtained with at most two of each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n+1 \times w+1$ initialized with 0,0 \; 

  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{
      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;
      \Comment{Case 2: Take 1 of item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[i])$\;
      }
      \Comment{Case 3: Take 2 of item 1}

      \If{$j \geq 2w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-2w[i]] + 2value[i])$\;
      }
    }
  }

  \Return{$dp[n][w]$} \;
}
\end{algorithm}

\newpage
\section{Modified Edit Distance (20 points)}
\subsection{Part A (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Either insert or delete
  %min(DP[i-1][j] + 1, DP[i][j-1] + 1)  & \text{otherwise}
  DP[i-1][j] + 1 & \text{if } (A[i] \neq B[j])\\ 
  DP[i][j-1] + 1 & \text{if } (A[i] \neq B[j])\\ 
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills a $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.

\end{itemize}

\newpage
\section{Part B (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Deletion
  DP[i-1][j] + C_D & \text{if } (A[i] \neq B[j])\\
  % Insertion
  DP[i][j-1] + C_I & \text{if } (A[i] \neq B[j])\\
  % Modification
  DP[i-1][j-1] + C_M & \text{if } (A[i] \neq B[j])
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills a $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.
  \item Despite the added cost of modification, the time complexity remains the same.
    Since the table is filled in constant time, the time complexity is not affected.
\end{itemize}

\newpage
\section{Tipping the Scales (20 points)}
\noindent\textbf{Algorithm:} \\
Describe the algorithm here: \\
\begin{itemize}
  \item Input: Array B[] size $n$ of balance thresholds and array W[] size $n$ of stone weights.
  \item Output: Maximum number of balances that can be tipped.
\end{itemize}

\begin{enumerate}
  \item Sort $B[]$ and $W[]$ increasing order
  \item Init $count$ = 0
  \item Init $i = 1$ (index for balances), $j = 1$ (index for stones)
  \item While $i$ \leq $n$ and $j$ \leq $n$ do:
    \begin{enumerate}
      \item If $W[j]$ \leq $B[i]$ then:
        \begin{enumerate}
          \item Assign $j$ to balance $i$
          \item Increment $i$
          \item Increment $i$ and $j$
        \end{enumerate}
        Else:
        \begin{enumerate}
          \item Increment $j$ // Stone too light, try next one
        \end{enumerate}
    \end{enumerate}
  \item Return $count$
\end{enumerate}
\noindent\textbf{Greedy Choice:} \\
\begin{itemize}
  \item Why this choice is the best choice for the sub-problem.
    \begin{itemize}
      \item Suppose balance $B[i]$ is the one with the smallest threshold.
      \item Let $w[j]$ be the smallest stone weight 
        that satisfies $W[j]$ \geq $B[i]$.
        % TODO: Go through this again
      \item If an optimal solution used a heavier stone $W[k]$ (with $k>j$) to tip
        $B[i]$, then $W[j]$ (which is lighter but still satisfies the threshold)
        would be available.
    \end{itemize}
  \item Argument:
    \begin{itemize}
      \item Given we replace stone $W[k]$ in the optimal solution with $W[j]$
      \item Since $W[j]$ is lighter ($W[j] \leq W[k]$), and still meets
        the threshold $B[i]$ is still valid. But using lighter stone for $B[i]$
        may allow for heavier stones to be saved for balances with higher requirements.
    \end{itemize}
  \item Conclusion:
    \begin{itemize}
      \item This shows there is an optimal solution that uses the lightest stone
        that meets the threshold for each balance.
    \end{itemize}
\end{itemize}

\pagebreak
\noindent\textbf{Optimal Substructure:} \\
Explanation and proof of optimal substructure: \\
\begin{itemize}
  \item Decomposition
    \begin{itemize}
      \item Once you assign stone $W[j]$ to balance $B[i]$.
        The remaining sub-problem is to assign the remaining stones to the remaining balances.
    \end{itemize}
  \item Inductive Argument:
    \begin{itemize}
      \item Suppose the optimal solution is to assign stone $W[j]$ to balance $B[i]$.
      \item By making greedy assignment for balance $B[i]$, that implies
        the existance of an optimal solution for the remaining $n-1$ balances and stones; the sub-problem.
      \item If not, we can assume a better solution for the remaining sub-problem.
      \item Combining the greedy solution for balance $B[i]$ with the optimal solution for the remaining sub-problem
        gives a better solution than the original "optimal" solution, causing a contradiction.
    \end{itemize}
  \item Conclusion:
    \begin{itemize}
      \item The optimal solution for the problem can be built from the optimal solution of the sub-problems.
        Further proving the problem contains an optimal substructure.
    \end{itemize}
\end{itemize}

\newpage
\section{High Throughput (20 points)}
\noindent\textbf{Algorithm:} \\
\begin{enumerate}
  \item Provide greedy Algorithm that runs in $O(nlogn)$ time and minimizes total queue times
    \begin{itemize}
      \item Sort the tasks t[] of length n. $O(nlogn)$
      \item Then operate each tasks from 1 to n. $O(n)$
    \end{itemize}
  \item Provide correctness by showing greedy choice and optimal substructure properties.
    \begin{itemize}
      \item The greedy algorithm is correct
    \end{itemize}
\end{enumerate}

\noindent\textbf{Greedy Choice:} \\
\noindent\textbf{Optimal Substructure:} \\

\newpage
\section{Task Scheduling (20 points)}


\end{document}

