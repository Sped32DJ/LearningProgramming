\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59 PM, 3/4/2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Net ID: dtope004 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

\def\isinput{} % Exclude preamble in questions
\begin{document}

\assigntitle{4}{}
\policy{\textbf{Deadline.} The homework is due 11:59 PM, 3/4/2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
    \item Unless stated in the question, your designed algorithm should use the most optimized algorithm you have learned so far. A too-complex algorithm may result in penalties.
\end{itemize}


}

\section{0/1 Knapsack (20 points)}
\subsection{Part A (10 Points)}

\noindent\textbf{Recurrence:} \\

  
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item The $DP[i][j]$ represents 
  \item Given budget $j$, the maximum value that can be obtained by including the first $i$ items.
\end{itemize}
\noindent\textbf{Dimensions:} \\
The dimensionality of $DP[i][j]$ is 2-dimensional.
\begin{enumerate}
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
\end{enumerate}

\pagebreak
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/1 Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items $n$ inidexed by $i$ with weights $w_i$ and a budget $w$ and values $v_i$}
\KwOut{Maximum value that can be obtained with at most one each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n \times w$ initialized with 0,0 \;
  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{

      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;

      \Comment{Case 2: Take item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[j])$\;
      }
    }
  }

  \Return{$dp[i][j]$} \;
}
\end{algorithm}

\pagebreak
\subsection{Part B (10 Points)}
New problem statement, instead of being limited to 0 or 1 item, now we can have 0, 1, or 2 of the item.
We want to have the maximum value of the items without exceeding the weight limit of the Knapsack.\\

\noindent\textbf{Recurrence:} \\
DP[i][j] = $max$
$\begin{cases}
     DP[i-1][j] \\
     DP[i-1][j-w_i] + v_i & \text{if } j > w_i \\
     DP[i-1][j-2w_i] + 2v_i & \text{if } j > 2w_i \\
%    \max\{v_i + K[i-1, w-w_i], K[i-1, w]\} & \text{otherwise}
  
\end{cases}$ \\

Boundary: $DP[i][0] = 0$ and $DP[0][j] = 0$ \\

\noindent\textbf{Table Interpretation:} \\
\begin{itemize}
  \item Just like the previous problem, the $DP[i][j]$ represents the maximum value that can be obtained by including the first $i$ items.
  \item The only difference is that we can have 0, 1, or 2 of the item. This can be represented by the second dimension $j$.
    \begin{itemize}
      \item Showing that we can have 0,1,2 items is modified by adding one more case to the recurrence.
    \end{itemize}
\end{itemize}
\noindent\textbf{Dimensions:} \\
\begin{itemize}
  \item The dimensionality of $DP[i][j]$ is 2 dimensional.
  \item The first dimension $i$ represents the number of items that can be included in the knapsack.
  \item The second dimension $j$ represents the weight of the knapsack.
  
\end{itemize}

\pagebreak 
\noindent\textbf{pseudocode:} \\

\begin{algorithm}[H]
 \caption{O/I Knapsack}
%\KwIn{A list of items $i$ and a budget $j$}
 \KwIn{A list of items indexed by $i$ with weights $w_i$ and values $v_i$ and a budget $w$}
\KwOut{Maximum value that can be obtained with at most two of each item}

\SetKwFunction{FMain}{Knapsack}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  let $dp$ be a 2D array of size $n+1 \times w+1$ initialized with 0,0 \; 

  \For{$i \gets 1$ \textbf{to} $n$}{
    \For{$j \gets 0$ \textbf{to} $w$}{
      \Comment{Case 1: Do not take item 1}

      dp[i][j] = dp[i-1][j]\;
      \Comment{Case 2: Take 1 of item 1}

      \If{$j \geq w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-w[i]] + value[i])$\;
      }
      \Comment{Case 3: Take 2 of item 1}

      \If{$j \geq 2w[i]$}{
        $dp[i][w] = max(dp[i][j]$, $dp[i-1][j-2w[i]] + 2value[i])$\;
      }
    }
  }

  \Return{$dp[n][w]$} \;
}
\end{algorithm}

\newpage
\section{Modified Edit Distance (20 points)}
\subsection{Part A (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Either insert or delete
  %min(DP[i-1][j] + 1, DP[i][j-1] + 1)  & \text{otherwise}
  DP[i-1][j] + 1 & \text{if } (A[i] \neq B[j])\\ 
  DP[i][j-1] + 1 & \text{if } (A[i] \neq B[j])\\ 
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills a $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.

\end{itemize}

\subsection{Part B (10 Points)}
\noindent\textbf{Recurrence:} \\
DP[i][j] = $\min$
$\begin{cases}
  % Same chartacter, cost 0
  DP[i-1][j-1] & \text{if } (A[i] == B[j])\\
  % Deletion
  DP[i-1][j] + C_D & \text{if } (A[i] \neq B[j])\\
  % Insertion
  DP[i][j-1] + C_I & \text{if } (A[i] \neq B[j])\\
  % Modification
  DP[i-1][j-1] + C_M & \text{if } (A[i] \neq B[j])
\end{cases}$

\noindent\textbf{Time Complexity:} \\
\begin{itemize}
  \item Each cell in the table is filled in constant time.
  \item Given that the algorithm fills a $(n+1) \times (m+1)$ table, 
    making the time complexity is $O(nm)$.
  \item Despite the added cost of modification, the time complexity remains the same.
    Since the table is filled in constant time, the time complexity is not affected.
\end{itemize}

\newpage
\section{Tipping the Scales (20 points)}
\noindent\textbf{Algorithm:} \\
Describe the algorithm here: \\
\begin{itemize}
  \item Input: Array B[] size $n$ of balance thresholds and array W[] size $n$ of stone weights.
  \item Output: Maximum number of balances that can be tipped.
\end{itemize}

\begin{enumerate}
  \item Sort $B[]$ and $W[]$ increasing order
  \item Init $count$ = 0
  \item Init $i = 1$ (index for balances), $j = 1$ (index for stones)
  \item While $i$ \leq $n$ and $j$ \leq $n$ do:
    \begin{enumerate}
      \item If $W[j]$ \leq $B[i]$ then:
        \begin{enumerate}
          \item Assign $j$ to balance $i$
          \item Increment $i$
          \item Increment $i$ and $j$
        \end{enumerate}
        Else:
        \begin{enumerate}
          \item Increment $j$ // Stone too light, try next one
        \end{enumerate}
    \end{enumerate}
  \item Return $count$
\end{enumerate}
\noindent\textbf{Greedy Choice:} \\
\begin{itemize}
  \item Why this choice is the best choice for the sub-problem.
    \begin{itemize}
      \item Suppose balance $B[i]$ is the one with the smallest threshold.
      \item Let $w[j]$ be the smallest stone weight 
        that satisfies $W[j]$ \geq $B[i]$.
        % TODO: Go through this again
      \item If an optimal solution used a heavier stone $W[k]$ (with $k>j$) to tip
        $B[i]$, then $W[j]$ (which is lighter but still satisfies the threshold)
        would be available.
    \end{itemize}
  \item Argument:
    \begin{itemize}
      \item Given we replace stone $W[k]$ in the optimal solution with $W[j]$
      \item Since $W[j]$ is lighter ($W[j] \leq W[k]$), and still meets
        the threshold $B[i]$ is still valid. But using lighter stone for $B[i]$
        may allow for heavier stones to be saved for balances with higher requirements.
    \end{itemize}
  \item Conclusion:
    \begin{itemize}
      \item This shows there is an optimal solution that uses the lightest stone
        that meets the threshold for each balance.
    \end{itemize}
\end{itemize}

\pagebreak
\noindent\textbf{Optimal Substructure:} \\
Explanation and proof of optimal substructure: \\
\begin{itemize}
  \item Decomposition
    \begin{itemize}
      \item Once you assign stone $W[j]$ to balance $B[i]$.
        The remaining sub-problem is to assign the remaining stones to the remaining balances.
    \end{itemize}
  \item Inductive Argument:
    \begin{itemize}
      \item Suppose the optimal solution is to assign stone $W[j]$ to balance $B[i]$.
      \item By making greedy assignment for balance $B[i]$, that implies
        the existance of an optimal solution for the remaining $n-1$ balances and stones; the sub-problem.
      \item If not, we can assume a better solution for the remaining sub-problem.
      \item Combining the greedy solution for balance $B[i]$ with the optimal solution for the remaining sub-problem
        gives a better solution than the original "optimal" solution, causing a contradiction.
    \end{itemize}
  \item Conclusion:
    \begin{itemize}
      \item The optimal solution for the problem can be built from the optimal solution of the sub-problems.
        Further proving the problem contains an optimal substructure.
    \end{itemize}
\end{itemize}

\newpage
\section{High Throughput (20 points)}
\noindent\textbf{Algorithm:} \\
   Provide greedy Algorithm that runs in $O(nlogn)$ time and minimizes total queue times
    \begin{enumerate}
      \item Sort the tasks t[] of length n.  // $O(nlogn)$
      \item Init $T_{sum} = 0$
      \item In a for loop $t[i]$ i = 1 to $n$ do: // $O(n)$ \\
        $T_{sum} += t[i]$
      \item \textbf{return} $T_{sum}$
    \end{enumerate}

\noindent\textbf{Greedy Choice:} \\

  Provide correctness by showing greedy choice and optimal substructure properties.
    \begin{itemize}
      \item \textbf{Claim:} In an optimal solution, the task with the shortest time should be scheduled first.
      \item \textbf{Proof:} Suppose there exists an optimal solution where the task with the shortest time is not scheduled first.
        Lets assume $t[i]$ is the task with the shortest time that is not scheduled first.
        \begin{itemize}
          \item $t[j]$ contributes its full runtime to waiting for every task that is scheduled before it, including $t[i]$.
          \item If we schedule $t[i]$ first, every task that occurs after $t[i]$ 
            will have to wait for $t[i]$ to finish rather than $t[j]$.
          \item This would reduce the wait time for all the following task by $t[j] - t[i]$.
          \item Given that the wait time for tasks is reduced, the total wait time is minimized. Making this an optimal solution and better
            than the original solution.
        \end{itemize}
    \end{itemize}

\noindent\textbf{Optimal Substructure:} \\
\begin{itemize}
  \item \textbf{Claim:} After the greedy choice, the remaining sub-problem is the 
    same problem that will result in an optimal solution given we use the same greedy choice on the sub-problem.
  \item \textbf{Proof:} Once we schedule the shortest tasks, from the sub-problem of remaining tasks.
    We would grab the next shortest tasks to schedule it at after the previous shortest task and so on.
\end{itemize}

\newpage
\section{Task Scheduling (20 points)}
\textbf{Algorithm:} \\
\begin{enumerate}
  \item The number of overlaps for each task
  \item Sorting the tasks in increasing number of overlaps, then breaking the ties arbitrarily.
  \item Pick task $i$ with the smallest number of overlaps, schedule it, then remove it. Also remove tasks that conflict with task $i$.
  \item Repeat step 3 until no task remains
\end{enumerate}

\textbf{Claim:}
\begin{itemize}
  \item The greedy choice of taking the minimun-overlap is not optimal.
  \item We are only computing the number of overlaps once, and not updating the number of overlaps after each task is scheduled.
  \item It does not really take into account the number of overlaps that are removed after each task is scheduled.
%  \item Neither does it consider the "cost" of choosing an interval when it comes to building a conflict-free schedule.
\end{itemize}

\textbf{Proof by counter example:}

\begin{tikzpicture}[xscale=1.5, yscale=1.0]

  % Draw horizontal time axis
  \draw[->] (0,0) -- (6,0) node[right] {Time};
  \foreach \x in {1,1.5,2,2.5,3,3.5,4,4.5,5}
    \draw (\x,0) -- (\x,-0.2) node[below] {\x};

  % Draw intervals on separate horizontal levels:
  % A: [1, 1.5] at y=1, overlap count 2
  \draw[thick, blue] (1,1) -- (1.5,1) node[midway, above] {A};
  \node at (1.75,1) {2};

  % B: [1, 2] at y=2, overlap count 3
  \draw[thick, red] (1,2) -- (2,2) node[midway, above] {B};
  \node at (2.25,2) {3};

  % C: [2, 3] at y=3, overlap count 4
  \draw[thick, green!70!black] (2,3) -- (3,3) node[midway, above] {C};
  \node at (3.25,3) {4};

  % D: [3, 4] at y=4, overlap count 3
  \draw[thick, purple] (3,4) -- (4,4) node[midway, above] {D};
  \node at (4.25,4) {3};

  % J: [3.5, 4.5] at y=4.5, overlap count 3
  \draw[thick, violet] (3.5,4.5) -- (4.5,4.5) node[midway, above] {J};
  \node at (4.75,4.5) {3};

  % E: [4, 5] at y=5, overlap count 2
  \draw[thick, orange] (4,5) -- (5,5) node[midway, above] {E};
  \node at (5.25,5) {2};

  % F: [1, 4.5] at y=6, overlap count 8
  \draw[thick, black] (1,6) -- (4.5,6) node[midway, above] {F};
  \node at (4.75,6) {8};

  % G: [1.5, 2.5] at y=7, overlap count 4
  \draw[thick, cyan] (1.5,7) -- (2.5,7) node[midway, above] {G};
  \node at (2.75,7) {4};

  % H: [2.5, 3.5] at y=8, overlap count 3
  \draw[thick, magenta] (2.5,8) -- (3.5,8) node[midway, above] {H};
  \node at (3.75,8) {3};

  % I: [2, 3.5] at y=9, overlap count 4
  \draw[thick, brown] (2,9) -- (3.5,9) node[midway, above] {I};
  \node at (3.75,9) {4};

\end{tikzpicture}

\begin{itemize}
  \item (The number represents the amount of conflicts; Like A would have 2 conflicts)
  \item Given that D, J, H all have the same amount of conflicts. That means it can chose any of these decisions arbitrarily.
  \item The optimal solution would include C,D,E. But the issue is that C has a conflict counter of 4 and will not be added
    onto the solution until after this decision is made.
  \item Since the conflicts are not updated after each task is scheduled, the greedy algorithm could choose H or D.
    Arbitrarily, choosing H would mean we can't have the optimal solution of C,D,E. 
    Instead we would have H, then E. Since H overlaps D and C, but D and C don't 
    overlap each other (making C then D part of the optimal solution).
  \item Non optimal solutions with a low conflict counter will be chosen over the 
    optimal solutions that include tasks with higher conflict counters.
\end{itemize}

\end{document}

