\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
%\usepackage{mathtools}
\usepackage{forest}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59 PM, 3/15/2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Net ID: dtope004 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Very Important: Promote subsection to section %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\subsection\section

\def\isinput{} % Exclude preamble in questions
\begin{document}

\assigntitle{5}{}
\policy{\textbf{Deadline.} The homework is due 11:59 PM, 3/15/2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
    \item Unless stated in the question, your designed algorithm should use the most optimized algorithm you have learned so far. A too-complex algorithm may result in penalties.
\end{itemize}


}


\section{Reverse Delete (20 points)}
\begin{itemize}
  \item \textbf{Reverse Delete} is not the most efficient algorithm for computing the minimum spanning tree of a graph.
    However, it does compute the optimal MST.
  \item An MST has the following characteristics, it is an acyclic, connected graph with $n-1$ edges
    of minimum cost.
  \item The Reverse Delete algorithm is removing the more expensive edges first, as long as it doesn't disconnect the graph.
  \item This approach works since an MST algorithm should do the following.
    Takes out all the redundant edges and leaves the most cost-effective ones.
    All while keeping the graph connected
\end{itemize}

\textbf{Proof of Correctness (proving optimal substructure):}

Consider an edge \( e \) processed in decreasing order of weight. Two cases arise:
\begin{enumerate}
    \item If \( e \) is not a bridge in the current graph \( G' \),
      then there exists an alternative and more efficient path between its endpoints.
      Making \( e \) the maximal weight edge on a cycle.
      By the \textbf{cycle property}, \( e \) cannot belong to any MST.
      Therefore, the optimal choice would be to delete \( e \).
    \item If \( e \) is a bridge, then its removal would disconnect \( G' \).
      Moreover, \( e \) is the only edge connecting the two components due to the reverse order of edge deletions.
      In this case, \( e \) must be included in every spanning tree, and the algorithm keeps it.
\end{enumerate}
At every step, the algorithm takes the locally optimal, greedy decision. \\

\textbf{Conclusion: }
Let \( G' \) be the connected graph after a couple iterations of the algorithm.
Suppose the algorithm removes an edge \( e \) (case 1).
By the cycle property, no MST of \( G \) contains \( e \).
Therefore, any MST of \( G' - \{e\} \) is also an MST of \( G \).
If \( e \) is retained (case 2), then \( e \) is included in every MST
and the problem reduces to computing an MST for the smaller graph \( G' \) with \( e \) fixed.
By induction, the MST of the subgraph is optimal and, can be achieved through the greedy choice, yielding an optimal MST for \( G \).

Proving that optimal substructure holds.
Since both the greedy choice and optimal substructure properties hold, the Reverse-Delete algorithm correctly computes the MST.

\newpage
\section{Water Transport (20 points)}
\begin{enumerate}
  \item Representing problem as a graph problem: 
    \begin{itemize}
      \item We can begin with 3 nodes, $A$, $B$, and $C$. The following nodes form a complete graph.
      \item The edges represent the transportation of water between nodes.
      \item We would initialize these nodes as $A$ = 0/10, $B$ = 4/4, and $C$ = 7/7.
        With an included capacity and current weight.
      \item Now we can transfer the weights to each other until they have reached their max capacity, or the source node is empty.
    \end{itemize}
  \item An algorithm we can use to find the solution would be
    \begin{itemize}
      \item We can use BFS to explore the state space.
      \item BFS is an appropriate because it explores all reachable states from the initial state.
      \item It finds a solution with minimal pours.
      \item It can also conclude that no solution exists since it exhaustively traverses the entire state space.
    \end{itemize}
    \item This problem does have a solution
      \begin{enumerate}
        \item We begin with the initial state of ($A,B,C$) = (0/10,4/4,7/7).
        \item Pour from $C$ to $A$ to get (7/10,4/4,0/7).
        \item Pour from $B$ to $C$ to get (7/10,0/4,4/7).
        \item Pour from $C$ to $A$ to get (10/10,0/4,1/7).
        \item Pour from $A$ to $B$ to get (6/10,4/4,1/7).
        \item Pour from $B$ to $C$ to get (6/10,0/4,5/7). % 6
        \item Pour from $A$ to $B$ to get (2/10,4/4,5/7).
        \item Pour from $B$ to $C$ to get (2/10,2/4,7/7).
      \end{enumerate}
\end{enumerate}

\pagebreak

\begin{algorithm}[H]
\caption{BFS}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{$i$ and $j$}
\KwOut{$visited$ matrix}
\SetKwFunction{FMain}{BFS}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  q = []\;
  q.push((i,j))\;
  visited[i][j] = 1\;

  \While{q is not empty}{
    (x,y) = q.pop()\;
    \For{each (dx, dy) in directions}{
      newX = x + dx\;
      newY = y + dy\;
      \If{newX < 0 \textbf{OR} newX \geq m \textbf{OR} newY < 0 \textbf[OR] newY \geq n or visited[newX][newY] == 1 \textbf{OR} A[newX][newY] == 0}{
        \textbf{continue}\;
      }
      q.push((newX, newY))\;
      visited[newX][newY] = 1\;
    }
  }
}
\end{algorithm}

\begin{algorithm}[H]
\caption{WaterJugs}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{Three jugs with capacities $a$, $b$, and $c$}
\KwOut{isPossible boolean}
\SetKwFunction{FMain}{WaterJugs}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  start = (0,7,4)\;
  q = deque([start])\;
  visited = set()\;
  \While{q is not empty}{
    a,b,c = q.popleft()\;
    \If{$b$ == 2 \textbf{OR} $c$ == 2}{
      \Return{TRUE}\;
    }
    nextState = generateNextStates(a,b,c)\;

    \For{state in nextState}{
      \If{nextState not in visited}{
        q.append(state)\;
        visited.add(state)\;
      }
    }
  }
  \Return{FALSE}\; \Comment{No solution exists}
}
\end{algorithm}

\newpage
\section{Huffman Encoding (20 points)}
\begin{itemize}
  \item We can begin the Huffman encoding by grabbing the character frequency
    of the string "abracadabra".
  \item Frequency of characters: a = 5, b = 2, r = 2, c = 1, d = 1
%  \item The length of the code would be $\ceil[\big]{log_2(n)}$, where $n$ is the number of characters in the string.
\end{itemize}

\begin{forest}
for tree={align=center, l sep=20pt, s sep=15pt, edge={->}, parent anchor=south, child anchor=north}
[11
  [a\\(5) \\ Code: 0]
  [6
    [2
      [c\\(1) \\ Code: 100]
      [d\\(1) \\ Code: 101]
    ]
    [4
      [b\\(2) \\ Code: 110]
      [r\\(2) \\ Code: 111]
    ]
  ]
]
\end{forest}
\begin{itemize}
  \item a = 5 instance * 1 bit  = 5 bits
  \item b = 2 instance * 3 bits = 6 bits
  \item r = 2 instance * 3 bits = 6 bits
  \item c = 1 instance * 3 bits = 3 bits
  \item d = 1 instance * 3 bits = 3 bits
  \item The total length of encoding "abracadabra" would be length of 23 bits.
\end{itemize}

\newpage
\section{Bipartite Graphs (20 points)}
\begin{itemize}
  \item Bipartite graphs are two colorable graphs.
  \item Write BFS-based algorithm that determines if a graph is bipartite.
  \item Assume graph is connected and represented as an adjacency list.

\end{itemize}

\begin{algorithm}[H]
\caption{BFS Bipartite}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{Graph G = (V,E) represented as an adjacency list}
\KwOut{(set1,set2) if $G$ is bipartite, otherwise None}

\SetKwFunction{FMain}{BFS Bipartite}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{

  \Comment{Set 1 holds the nodes with color R, and set 2 holds the nodes with color B}

  Let $set1$ and $set2$ be two empty sets\;

  \Comment{The nodes can have three colors: R (red), B (blue), and N (None)}

  Let $s$ be any vertex in $V$\;
  $s$.color = R\;
  add $s$ to $set1$\;

  Let q be an empty queue\;
  q.enqueue($s$)\;

  \Comment{BFS traversal of the graph}

  \While{q is not empty}{
    Let $u$ be q.dequeue()\;
    \For{each vertex $v$ adjacent to $u$}{
      \If{$v$.color == N}{
        \If{$u$.color == R}{
          $v$.color = B\;
          add $v$ to $set2$\;
        }
        \Else{
          $v$.color = R\;
          add $v$ to $set1$\;
        }
        q.enqueue($v$)\;
      }
      \ElseIf{$v$.color == $u$.color}{
        \Comment{If the adjacent nodes have the same color, then the graph is not bipartite}
        \Return{None}\;
      }
    }
  }

  \Comment{BFS reaches this stage, the graph is bipartite}

  \Return{$(set1, set2)$} \;
}
\end{algorithm}

% Bonus Qs
\newpage
\section{Infrastructure (10 point bonus)}
<<<<<<< HEAD

=======
>>>>>>> refs/remotes/origin/main
  \textbf{1. Checking Feasibility in Linear Time}\\
  The route is feasible if every highways (edge) on the route has a length $l_e$ < $L$. 
  With graph $G$ we can make $G'$ where we remove all edges that do not satisfy the constraint.
  After removing the edges, we can check if the $s$ (source) and $t$ (target) are connected in $G'$.

  \textbf{Algorithm:}
  \begin{enumerate}
    \item Filter Edges:
      \begin{itemize}
        \item For every edge $e$ in $E$, remove $e$ if $l_e$ > $L$.
        \item This step should take O($m$) time. Given m = |E|
      \end{itemize}
    \item Check Connectivity:
      \begin{itemize}
        \item Using BFS starting from $s$ to see if $t$ is reachable.
        \item Graph traversal algorithms take O($n$ + $m$) time.
      \end{itemize}
    \item Return Result:
      \begin{itemize}
        \item If $t$ is reachable from $s$, then the route is feasible.
        \item Otherwise, the route is not feasible.
      \end{itemize}
  \end{enumerate}

  \textbf{2. Finding the Shortest Path}\\


\begin{algorithm}[H]
\caption{Min Fuel Capacity}
\KwIn{Graph $G = (V, E)$ with edge weights $l_e$, source $s$, and target $t$}
\KwOut{The minimum fuel capacity $L$ needed to travel from $s$ to $t$}

\SetKwFunction{FMain}{MinFuelCap}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$n$, $w$}}{
  \For{Each vertex $v \in V$}{
    $d(v) = \infty$\;
  }
  $d(s) = 0$\;

  Let $q$ be an empty priority queue\;
  Insert $s$ into $q$\;

  \While{$q$ is not empty}{
    Let $u$ be the vertex with the minimum distance in $q$\;
    Remove $u$ from $q$\;
    \For{each vertex $v$ adjacent to $u$}{
      \If{$d(v) > \max(d(u), l_{uv})$}{
        $d(v) = \max(d(u), l_{uv})$\;
        Insert $v$ into $q$\;
      }
    }
  }

  \Return{$d(t)$}\;
}
\end{algorithm}

\newpage
\section{Boolean Matrix (10 point bonus)}

\begin{algorithm}[H]
\caption{BFS}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{$i$ and $j$}
\KwOut{$visited$ matrix}
\SetKwFunction{FMain}{BFS}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  q = []\;
  q.push((i,j))\;
  visited[i][j] = 1\;

  \While{q is not empty}{
    (x,y) = q.pop()\;
    \For{each (dx, dy) in directions}{
      newX = x + dx\;
      newY = y + dy\;
      \If{newX < 0 \textbf{OR} newX \geq m \textbf{OR} newY < 0 \textbf[OR] newY \geq n or visited[newX][newY] == 1 \textbf{OR} A[newX][newY] == 0}{
        \textbf{continue}\;
      }
      q.push((newX, newY))\;
      visited[newX][newY] = 1\;
    }
  }
}
\end{algorithm}


\textbf{1. O($mn$) algorithm for largest component}


\begin{algorithm}[H]
\caption{Determine largest image}
\KwIn{Matrix $A$ of 0's and 1's}
\KwOut{Largest connected component size}

\SetKwFunction{FMain}{LargestImage}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  $m$ = A.rows\;
  $n$ = A.columns\;

  Initialize a matrix \texttt{visited} of size $m \times n$ with all 0's\;

  Initialize \texttt{maxSize} = 0\;
  Define \texttt{directions} = [(1,0), (-1,0), (0,1), (0,-1)] \tcp{Up, Down, Left, Right}

  \For{i from 0 to $m-1$}{
    \For{j from 0 to $n-1$}{
      \If{A[i][j] == 1 \textbf{AND} visited[i][j] == 0 }{
        size = BFS(i,j)\;
        maxSize = \texttt{max(maxSize, size)}\;
      }
    }
  }

  \Return{\texttt{maxSize}}\;
}
\end{algorithm}

\newpage

\textbf{2. O($mn$) algorithm determine number of images}

\begin{algorithm}[H]
\caption{Determine number of images}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{Matrix $A$ size $m \times n$ of 0's and 1's}
\KwOut{$numComponents$}
\SetKwFunction{FMain}{numComponents}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  $m$ = A.rows\;
  $n$ = A.columns\;

  Let $visited$ be a matrix of size $m \times n$ with all 0's\;
  $numComponents$ = 0\;
  Define \texttt{directions} = [(1,0), (-1,0), (0,1), (0,-1)] \tcp{Up, Down, Left, Right}

  \For{i from 0 to $m-1$}{
    \For{j from 0 to $n-1$}{
      \If{M[i][j] = 1 AND visited[i][j] == 0}{
        ++numComponents\;
        BFS(i,j)\;
  }
  \Return{$numComponents$}\;
}
}
}
\end{algorithm}


\newpage
\section{Two Parts (10 point bonus)}

\begin{algorithm}[H]
\caption{DFS}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{$x$ and $y$}
\KwOut{$visited$ matrix}
\SetKwFunction{FMain}{DFS}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  \If{x < 0 \textbf{OR} x \geq m \textbf{OR} y < 0 \textbf{OR} y \geq n or A[x][y] == 0 \textbf{OR} visited[x][y] == 1}{
    \Return
  }
  visited[x][y] = 1\;
  \For{each $(dx, dy)$ in \texttt{directions}}{
    DFS(x+dx, y+dy)\;
  }
}
\end{algorithm}

\begin{algorithm}[H]
\caption{Modified Counting Components}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{Matrix $A$ size $m \times n$ of 0's and 1's}
\KwOut{int $images$}
\SetKwFunction{FMain}{modifiedCountComponents}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  $m$ = A.rows\;
  $n$ = A.columns\;
  init $visited$[m][n] = {0}\;
  Define \texttt{directions} = [(1,0), (-1,0), (0,1), (0,-1)] \tcp{Up, Down, Left, Right}

  \For{i from 0 to $m-1$}{
    \For{j from 0 to $n-1$}{
      \If{A[i][j] == 1 and visited[i][j] == 0}{
        DFS(i,j)\;
        ++count\;
      }
    }
  }

}
\end{algorithm}

\begin{algorithm}[H]
\caption{Modified Counting Components}
%\KwIn{A list of items $i$ and a budget $j$}
\KwIn{$A$}
\KwOut{$numComponents$}
\SetKwFunction{FMain}{ModifiedCountComponents}
\SetKwProg{Fn}{Function}{:}{}
\Fn{\FMain{$A$}}{
  Init $visited$[m][n] = {0}\;
  $count$ = 0\;
  $m$ = A.rows\;
  $n$ = A.columns\;

  directions = [(1,0), (-1,0), (0,1), (0,-1), (1,1), (1,-1), (-1,1), (-1,-1)] \Comment{with diagonals}

  \For{i from 0 to $m-1$}{
    \For{j from 0 to $n-1$}{
      \If{A[i][j] == 1 and visited[i][j] == 0}{
        DFS(i,j)\;
        ++count\;
      }
    }
  }
  \Return{count}\;
}
\end{algorithm}



\end{document}

