\documentclass{article}[12pt]
\usepackage{fullpage}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage[ruled,lined,linesnumbered]{algorithm2e}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{enumitem}
\usepackage{url}
\usepackage{graphicx}
\usepackage{listings}
%\usepackage{mathtools}
\usepackage{forest}

\ifx\solutiontemplate\undefined
\newcommand{\solkeyword}[1]{}
\newcommand{\policy}[1]{#1}
\else
\newcommand{\solkeyword}[1]{#1}
\newcommand{\policy}[1]{}
\fi

\newcommand\encircle[1]{\raisebox{.5pt}{\textcircled{\raisebox{-.9pt} {\footnotesize #1}}} }


\newenvironment{solution}[0]{\vspace{.1in} \textbf{Solution.} \,}{}

\newcommand{\deadline}{11:59 PM, 3/15/2025}

\newcommand{\assigntitle}[1]{{
  \noindent \large \bf
  CS141, Winter 2025,
  Assignment \##1 \hfill Due: {\deadline}\\
  Name: Danny Topete %put in your name here
  \hspace{2.5in}
  Net ID: dtope004 %put in your id here
  \\
  [-.05in]
  \mbox{}\hrulefill \mbox{}\\}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Very Important: Promote subsection to section %%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\subsection\section

\def\isinput{} % Exclude preamble in questions
\begin{document}

\assigntitle{5}{}
\policy{\textbf{Deadline.} The homework is due 11:59 PM, 3/4/2025. You must submit your solutions (in pdf
format generated by LaTeX) via GradeScope. Canvas will not be accepted.}\\
\date{}
\policy{\textbf{Assignment Policy.}
\begin{itemize}
    \item Unless mentioned otherwise, late submission allowed for 20\% penalty for each calendar day.
    \item Assignments should be in pdf format generated by LaTeX
    \item If you are using any external source, you must cite it and clarify what exactly got out of it.
    \item You are expected to understand any source you use and solve problems in your own.
    \item All pages relevant to a question must be assigned on Gradescope. Unassigned pages will not be graded.
    \item Unless stated in the question, your designed algorithm should use the most optimized algorithm you have learned so far. A too-complex algorithm may result in penalties.
\end{itemize}


}


\section{Reverse Delete (20 points)}
\begin{itemize}
  \item \textbf{Reverse Delete} is not the most efficient algorithm for computing the minimum spanning tree of a graph.
    However, it does compute the optimal MST.
  \item An MST has the following characteristics, it is an acyclic, connected graph with $n-1$ edges
    of minimum cost.
  \item The Reverse Delete algorithm is removing the more expensive edges first, as long as it doesn't disconnect the graph.
  \item This approach works since an MST algorithm should do the following.
    Takes out all the redundant edges and leaves the most cost-effective ones.
    All while keeping the graph connected
\end{itemize}

\textbf{Proof of Correctness (proving optimal substructure):}

Consider an edge \( e \) processed in decreasing order of weight. Two cases arise:
\begin{enumerate}
    \item If \( e \) is not a bridge in the current graph \( G' \),
      then there exists an alternative and more efficient path between its endpoints.
      Making \( e \) the maximal weight edge on a cycle.
      By the \textbf{cycle property}, \( e \) cannot belong to any MST.
      Therefore, the optimal choice would be to delete \( e \).
    \item If \( e \) is a bridge, then its removal would disconnect \( G' \).
      Moreover, \( e \) is the only edge connecting the two components due to the reverse order of edge deletions.
      In this case, \( e \) must be included in every spanning tree, and the algorithm keeps it.
\end{enumerate}
At every step, the algorithm takes the locally optimal, greedy decision. \\

\textbf{Conclusion: }
Let \( G' \) be the connected graph after a couple iterations of the algorithm.
Suppose the algorithm removes an edge \( e \) (case 1).
By the cycle property, no MST of \( G \) contains \( e \).
Therefore, any MST of \( G' - \{e\} \) is also an MST of \( G \).
If \( e \) is retained (case 2), then \( e \) is included in every MST
and the problem reduces to computing an MST for the smaller graph \( G' \) with \( e \) fixed.
By induction, the MST of the subgraph is optimal and, can be achieved through the greedy choice, yielding an optimal MST for \( G \).

Proving that optimal substructure holds.
Since both the greedy choice and optimal substructure properties hold, the Reverse-Delete algorithm correctly computes the MST.

\newpage
\section{Water Transport (20 points)}
\begin{enumerate}
  \item Representing problem as a graph problem: 
    \begin{itemize}
      \item We can begin with 3 nodes, $A$, $B$, and $C$. The following nodes form a complete graph.
      \item The edges represent the transportation of water between nodes.
      \item We would initialize these nodes as $A$ = 0/10, $B$ = 4/4, and $C$ = 7/7.
        With an included capacity and current weight.
      \item Now we can transfer the weights to each other until they have reached their max capacity, or the source node is empty.
    \end{itemize}
  \item An algorithm we can use to find the solution would be
    \begin{itemize}
      \item We can use BFS to explore the state space.
      \item BFS is an appropaite appropriate because it explores all reachable states from the initial state.
      \item It finds a solution with minimal pours.
      \item It can also conclude that no solution exists since it exhaustively traverses the entire state space.
    \end{itemize}
    \item This problem does have a solution, there are two approaches by doing a single pour: \\ 
      \begin{enumerate}
      \item You transfer two weights from $B$ to $A$, resulting in $B$ = 2/4 and $A$ = 2/10.
      \item You transfer five weights from $C$ to $A$, resulting in $C$ = 2/7 and  $A$ = 5/10.
      \item More approaches exist, but these are the two most optimal solutions (if the number of pours is a concern).
      \end{enumerate}
\end{enumerate}

\newpage
\section{Huffman Encoding (20 points)}
\begin{itemize}
  \item We can begin the Huffman encoding by grabbing the character frequency
    of the string "abracadabra".
  \item Frequency of characters: a = 5, b = 2, r = 2, c = 1, d = 1
%  \item The length of the code would be $\ceil[\big]{log_2(n)}$, where $n$ is the number of characters in the string.
\end{itemize}

\begin{forest}
for tree={align=center, l sep=20pt, s sep=15pt, edge={->}, parent anchor=south, child anchor=north}
[11
  [a\\(5) \\ Code: 0]
  [6
    [2
      [c\\(1) \\ Code: 100]
      [d\\(1) \\ Code: 101]
    ]
    [4
      [b\\(2) \\ Code: 110]
      [r\\(2) \\ Code: 111]
    ]
  ]
]
\end{forest}
\begin{itemize}
  \item a = 5*1 = 5
  \item b = 2*3 = 6
  \item r = 2*3 = 6
  \item c = 1*3 = 3
  \item d = 1*3 = 3
  \item The total length of encoding "abracadabra" would be length of 23 bits.
\end{itemize}

\newpage
\section{Bipartite Graphs (20 points)}
% Bonus Qs
\newpage
\section{Infrastructure (10 point bonus)}

\newpage
\section{Boolean Matrix (10 point bonus)}

\newpage
\section{Two Parts (10 point bonus)}

\end{document}

